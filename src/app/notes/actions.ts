
'use server';

import { z } from 'zod';
import { supabase } from '@/lib/supabase';
import { revalidatePath } from 'next/cache';

const NoteSchema = z.object({
  id: z.number().optional(),
  title: z.string().min(1, 'Title is required.'),
  content: z.string().optional(),
  tags: z.array(z.string()).optional(),
  is_pinned: z.boolean().optional(),
  folder_path: z.string().nullable().optional(),
});

export type Note = {
    id: number;
    created_at: string;
    title: string;
    content: string | null;
    tags: string[];
    is_pinned: boolean;
    folder_path: string | null;
};

const NOTES_TABLE = 'notes';

// This function will run once on server startup to ensure the table exists.
async function initializeDatabase() {
  if (!supabase) {
    console.log("Supabase not configured. Skipping database initialization.");
    return;
  };

  const setupSQL = `
      -- Create Notes Table if it doesn't exist
      CREATE TABLE IF NOT EXISTS public.${NOTES_TABLE} (
          id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          created_at timestamp with time zone NOT NULL DEFAULT now(),
          title text NOT NULL,
          content text,
          tags text[],
          is_pinned boolean DEFAULT false
      );

       -- Add RLS to Notes Table
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = '${NOTES_TABLE}' AND policyname = 'Allow public read access') THEN
            ALTER TABLE public.${NOTES_TABLE} ENABLE ROW LEVEL SECURITY;
            CREATE POLICY "Allow public read access" ON public.${NOTES_TABLE} FOR SELECT USING (true);
            CREATE POLICY "Allow public write access" ON public.${NOTES_TABLE} FOR INSERT WITH CHECK (true);
            CREATE POLICY "Allow public update access" ON public.${NOTES_TABLE} FOR UPDATE USING (true) WITH CHECK (true);
            CREATE POLICY "Allow public delete access" ON public.${NOTES_TABLE} FOR DELETE USING (true);
        END IF;
      END
      $$;

      -- Add folder_path column if it doesn't exist
      DO $$
      BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name='${NOTES_TABLE}' AND column_name='folder_path'
        ) THEN
            ALTER TABLE public.${NOTES_TABLE} ADD COLUMN folder_path text;
        END IF;
      END
      $$;

       -- Remove old folder_id column if it exists
      DO $$
      BEGIN
        IF EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name='${NOTES_TABLE}' AND column_name='folder_id'
        ) THEN
            -- First drop the constraint if it exists
            IF EXISTS (SELECT 1 FROM information_schema.table_constraints WHERE constraint_name='notes_folder_id_fkey' AND table_name='${NOTES_TABLE}') THEN
                ALTER TABLE public.${NOTES_TABLE} DROP CONSTRAINT notes_folder_id_fkey;
            END IF;
            ALTER TABLE public.${NOTES_TABLE} DROP COLUMN folder_id;
        END IF;
      END
      $$;
  `;

  // We are not using rpc here, as it doesn't handle multiple statements well.
  const { error } = await supabase.batch(setupSQL.split(';').filter(s => s.trim()));

  if (error) {
    console.error('Error during database initialization:', error.message);
  } else {
    console.log('Database initialization check complete.');
  }
}

// Run the initialization
if (process.env.NODE_ENV !== 'development' || process.env.VERCEL_ENV) {
    initializeDatabase().catch(console.error);
} else {
    // In development, we can run this without checking for the environment
    // to ensure the DB is set up on first run.
    initializeDatabase().catch(console.error);
}


export async function getNotes(): Promise<Note[]> {
  if (!supabase) return [];

  const { data, error } = await supabase
    .from(NOTES_TABLE)
    .select('*')
    .order('is_pinned', { ascending: false })
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching notes:', error.message);
    return [];
  }
  return data || [];
}

export async function getNoteById(id: number): Promise<Note | null> {
    if (!supabase) return null;

    const { data, error } = await supabase
        .from(NOTES_TABLE)
        .select('*')
        .eq('id', id)
        .single();
    
    if (error) {
        console.error(`Error fetching note ${id}:`, error.message);
        return null;
    }
    return data;
}

export async function createNote(title: string, folderPath: string | null = null): Promise<Note | null> {
  if (!supabase) return null;

  const { data, error } = await supabase
    .from(NOTES_TABLE)
    .insert({ title, content: '', tags: [], folder_path: folderPath })
    .select()
    .single();

  if (error) {
    console.error('Error creating note:', error.message);
    return null;
  }
  
  revalidatePath('/notes');
  if (data?.id) {
    revalidatePath(`/notes/${data.id}`);
  }
  return data;
}

export async function updateNote(note: Partial<Note> & { id: number }) {
    if (!supabase) return;
    
    const { error } = await supabase
        .from(NOTES_TABLE)
        .update(note)
        .eq('id', note.id);

    if (error) {
        console.error('Error updating note:', error.message);
    }
    revalidatePath('/notes');
    revalidatePath(`/notes/${note.id}`);
}

export async function deleteNote(id: number) {
    if (!supabase) return;

    const { error } = await supabase
        .from(NOTES_TABLE)
        .delete()
        .eq('id', id);

    if (error) {
        console.error('Error deleting note:', error.message);
    }
    revalidatePath('/notes');
    revalidatePath(`/notes/${id}`);
}
