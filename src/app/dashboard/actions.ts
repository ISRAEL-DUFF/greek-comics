
'use server';

import { supabase } from '@/lib/supabase';

const STORY_TABLE = 'comic_stories';
const EXPANDED_WORDS_TABLE = 'expanded_words';
const NOTES_TABLE = 'notes';

async function initializeAllTables() {
    if (!supabase) {
      console.log("Supabase not configured. Skipping all database initialization.");
      return;
    };
    
    const commands = [
        // Create Comic Stories Table
        `CREATE TABLE IF NOT EXISTS public.${STORY_TABLE} (
            id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            created_at timestamp with time zone NOT NULL DEFAULT now(),
            topic text,
            level text,
            grammar_scope text,
            story text,
            sentences jsonb,
            illustrations text[],
            glosses jsonb
        );`,
        `ALTER TABLE public.${STORY_TABLE} ENABLE ROW LEVEL SECURITY;`,
        `CREATE POLICY "Allow public read access" ON public.${STORY_TABLE} FOR SELECT USING (true);`,
        `CREATE POLICY "Allow public write access" ON public.${STORY_TABLE} FOR INSERT WITH CHECK (true);`,
        `CREATE POLICY "Allow public update access" ON public.${STORY_TABLE} FOR UPDATE USING (true) WITH CHECK (true);`,
        `CREATE POLICY "Allow public delete access" ON public.${STORY_TABLE} FOR DELETE USING (true);`,

        // Create Expanded Words Table
        `CREATE TABLE IF NOT EXISTS public.${EXPANDED_WORDS_TABLE} (
            id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            created_at timestamp with time zone NOT NULL DEFAULT now(),
            word text NOT NULL,
            expansion text,
            language character varying,
            lemma text,
            tags text[]
        );`,
        `ALTER TABLE public.${EXPANDED_WORDS_TABLE} ENABLE ROW LEVEL SECURITY;`,
        `CREATE POLICY "Allow public read access" ON public.${EXPANDED_WORDS_TABLE} FOR SELECT USING (true);`,
        `CREATE POLICY "Allow public write access" ON public.${EXPANDED_WORDS_TABLE} FOR INSERT WITH CHECK (true);`,
        `CREATE POLICY "Allow public update access" ON public.${EXPANDED_WORDS_TABLE} FOR UPDATE USING (true) WITH CHECK (true);`,
        `CREATE POLICY "Allow public delete access" ON public.${EXPANDED_WORDS_TABLE} FOR DELETE USING (true);`,

        // Create Notes Table
        `CREATE TABLE IF NOT EXISTS public.${NOTES_TABLE} (
            id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            created_at timestamp with time zone NOT NULL DEFAULT now(),
            title text NOT NULL,
            content text,
            tags text[],
            is_pinned boolean DEFAULT false,
            folder_path text,
            editor_type text DEFAULT 'default'::text
        );`,
        `ALTER TABLE public.${NOTES_TABLE} ENABLE ROW LEVEL SECURITY;`,
        `CREATE POLICY "Allow public read access" ON public.${NOTES_TABLE} FOR SELECT USING (true);`,
        `CREATE POLICY "Allow public write access" ON public.${NOTES_TABLE} FOR INSERT WITH CHECK (true);`,
        `CREATE POLICY "Allow public update access" ON public.${NOTES_TABLE} FOR UPDATE USING (true) WITH CHECK (true);`,
        `CREATE POLICY "Allow public delete access" ON public.${NOTES_TABLE} FOR DELETE USING (true);`
    ];

    for (const command of commands) {
        const { error } = await supabase.sql(command);
        if (error) {
            // Ignore "already exists" errors for policies and tables, but log others.
            if (!error.message.includes('already exists')) {
                 console.warn('Initialization command warning:', error.message);
            }
        }
    }
    console.log('All tables database initialization check complete.');
}


export type StoriesByLevel = {
  level: string;
  count: number;
};

export type DashboardMetrics = {
  storyCount: number;
  wordCount: number;
  noteCount: number;
  storiesByLevel: StoriesByLevel[];
};

export async function getDashboardMetricsAction(): Promise<DashboardMetrics> {
  await initializeAllTables();

  if (!supabase) {
    return {
      storyCount: 0,
      wordCount: 0,
      noteCount: 0,
      storiesByLevel: [],
    };
  }

  try {
    const [
      { count: storyCount, error: storyError },
      { count: wordCount, error: wordError },
      { count: noteCount, error: noteError },
      { data: storiesByLevelData, error: storiesByLevelError },
    ] = await Promise.all([
      supabase.from(STORY_TABLE).select('*', { count: 'exact', head: true }),
      supabase.from(EXPANDED_WORDS_TABLE).select('*', { count: 'exact', head: true }),
      supabase.from(NOTES_TABLE).select('*', { count: 'exact', head: true }),
      supabase.from(STORY_TABLE).select('level'),
    ]);

    if (storyError || wordError || noteError || storiesByLevelError) {
      console.error('Error fetching dashboard metrics:', {
        storyError,
        wordError,
        noteError,
        storiesByLevelError,
      });
      throw new Error('Failed to fetch some or all dashboard metrics.');
    }

    const levelCounts: Record<string, number> = {
      Beginner: 0,
      Intermediate: 0,
      Advanced: 0,
    };

    storiesByLevelData?.forEach(story => {
      if (story.level && levelCounts.hasOwnProperty(story.level)) {
        levelCounts[story.level]++;
      }
    });

    const storiesByLevel: StoriesByLevel[] = Object.entries(levelCounts).map(
      ([level, count]) => ({ level, count })
    );

    return {
      storyCount: storyCount ?? 0,
      wordCount: wordCount ?? 0,
      noteCount: noteCount ?? 0,
      storiesByLevel,
    };
  } catch (error) {
    console.error('Unexpected error in getDashboardMetricsAction:', error);
    return {
      storyCount: 0,
      wordCount: 0,
      noteCount: 0,
      storiesByLevel: [],
    };
  }
}
