
'use server';

import { supabase } from '@/lib/supabase';

const STORY_TABLE = 'comic_stories';
const EXPANDED_WORDS_TABLE = 'expanded_words';
const NOTES_TABLE = 'notes';

// This function will run to ensure all necessary tables exist before fetching metrics.
async function initializeAllTables() {
    if (!supabase) {
      console.log("Supabase not configured. Skipping all database initialization.");
      return;
    };
  
    // SQL for all tables
    const setupSQL = `
        -- Create Comic Stories Table if it doesn't exist
        CREATE TABLE IF NOT EXISTS public.${STORY_TABLE} (
            id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            created_at timestamp with time zone NOT NULL DEFAULT now(),
            topic text,
            level text,
            grammar_scope text,
            story text,
            sentences jsonb,
            illustrations text[],
            glosses jsonb
        );
  
         -- Add RLS to Comic Stories Table
        DO $$
        BEGIN
          IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = '${STORY_TABLE}' AND policyname = 'Allow public read access') THEN
              ALTER TABLE public.${STORY_TABLE} ENABLE ROW LEVEL SECURITY;
              CREATE POLICY "Allow public read access" ON public.${STORY_TABLE} FOR SELECT USING (true);
              CREATE POLICY "Allow public write access" ON public.${STORY_TABLE} FOR INSERT WITH CHECK (true);
              CREATE POLICY "Allow public update access" ON public.${STORY_TABLE} FOR UPDATE USING (true) WITH CHECK (true);
              CREATE POLICY "Allow public delete access" ON public.${STORY_TABLE} FOR DELETE USING (true);
          END IF;
        END
        $$;

        -- Create Expanded Words Table if it doesn't exist
        CREATE TABLE IF NOT EXISTS public.${EXPANDED_WORDS_TABLE} (
            id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            created_at timestamp with time zone NOT NULL DEFAULT now(),
            word text NOT NULL,
            expansion text,
            language character varying,
            lemma text
        );
  
         -- Add RLS to Expanded Words Table
        DO $$
        BEGIN
          IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = '${EXPANDED_WORDS_TABLE}' AND policyname = 'Allow public read access') THEN
              ALTER TABLE public.${EXPANDED_WORDS_TABLE} ENABLE ROW LEVEL SECURITY;
              CREATE POLICY "Allow public read access" ON public.${EXPANDED_WORDS_TABLE} FOR SELECT USING (true);
              CREATE POLICY "Allow public write access" ON public.${EXPANDED_WORDS_TABLE} FOR INSERT WITH CHECK (true);
              CREATE POLICY "Allow public update access" ON public.${EXPANDED_WORDS_TABLE} FOR UPDATE USING (true) WITH CHECK (true);
              CREATE POLICY "Allow public delete access" ON public.${EXPANDED_WORDS_TABLE} FOR DELETE USING (true);
          END IF;
        END
        $$;
        
      -- Create Notes Table if it doesn't exist
      CREATE TABLE IF NOT EXISTS public.${NOTES_TABLE} (
          id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          created_at timestamp with time zone NOT NULL DEFAULT now(),
          title text NOT NULL,
          content text,
          tags text[],
          is_pinned boolean DEFAULT false,
          folder_path text
      );

       -- Add RLS to Notes Table
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = '${NOTES_TABLE}' AND policyname = 'Allow public read access') THEN
            ALTER TABLE public.${NOTES_TABLE} ENABLE ROW LEVEL SECURITY;
            CREATE POLICY "Allow public read access" ON public.${NOTES_TABLE} FOR SELECT USING (true);
            CREATE POLICY "Allow public write access" ON public.${NOTES_TABLE} FOR INSERT WITH CHECK (true);
            CREATE POLICY "Allow public update access" ON public.${NOTES_TABLE} FOR UPDATE USING (true) WITH CHECK (true);
            CREATE POLICY "Allow public delete access" ON public.${NOTES_TABLE} FOR DELETE USING (true);
        END IF;
      END
      $$;
    `;
  
    // We are not using rpc here, as it doesn't handle multiple statements well.
    const { error } = await supabase.batch(setupSQL.split(';').filter(s => s.trim()));
  
    if (error) {
      console.error('Error during all tables database initialization:', error.message);
    } else {
      console.log('All tables database initialization check complete.');
    }
}


export type StoriesByLevel = {
  level: string;
  count: number;
};

export type DashboardMetrics = {
  storyCount: number;
  wordCount: number;
  noteCount: number;
  storiesByLevel: StoriesByLevel[];
};

export async function getDashboardMetricsAction(): Promise<DashboardMetrics> {
  // Ensure tables exist before trying to fetch metrics.
  await initializeAllTables();

  if (!supabase) {
    // Return empty metrics if Supabase is not configured
    return {
      storyCount: 0,
      wordCount: 0,
      noteCount: 0,
      storiesByLevel: [],
    };
  }

  try {
    // Perform all count queries in parallel
    const [
      { count: storyCount, error: storyError },
      { count: wordCount, error: wordError },
      { count: noteCount, error: noteError },
      { data: storiesByLevelData, error: storiesByLevelError },
    ] = await Promise.all([
      supabase.from(STORY_TABLE).select('*', { count: 'exact', head: true }),
      supabase.from(EXPANDED_WORDS_TABLE).select('*', { count: 'exact', head: true }),
      supabase.from(NOTES_TABLE).select('*', { count: 'exact', head: true }),
      supabase.from(STORY_TABLE).select('level'),
    ]);

    if (storyError || wordError || noteError || storiesByLevelError) {
      console.error('Error fetching dashboard metrics:', {
        storyError,
        wordError,
        noteError,
        storiesByLevelError,
      });
      // Decide how to handle partial errors, for now, we'll return 0s
      // but you might want to return partial data or a more specific error.
      throw new Error('Failed to fetch some or all dashboard metrics.');
    }

    // Process the stories by level data
    const levelCounts: Record<string, number> = {
      Beginner: 0,
      Intermediate: 0,
      Advanced: 0,
    };

    storiesByLevelData?.forEach(story => {
      if (story.level && levelCounts.hasOwnProperty(story.level)) {
        levelCounts[story.level]++;
      }
    });

    const storiesByLevel: StoriesByLevel[] = Object.entries(levelCounts).map(
      ([level, count]) => ({ level, count })
    );

    return {
      storyCount: storyCount ?? 0,
      wordCount: wordCount ?? 0,
      noteCount: noteCount ?? 0,
      storiesByLevel,
    };
  } catch (error) {
    console.error('Unexpected error in getDashboardMetricsAction:', error);
    // In case of unexpected errors, return a default/empty state
    return {
      storyCount: 0,
      wordCount: 0,
      noteCount: 0,
      storiesByLevel: [],
    };
  }
}
